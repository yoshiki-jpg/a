-- SERVICES
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")

-- CONFIGURATION
local MAIN_GROUP = {
    Leader = {Name = "IlIIllIlIIllIlIIIlII", UserId = 5729726646},
    Members = {
        {Name = "lIlIIllIllIlIllIllIl", UserId = 5729724431},
        {Name = "IIllIlIIllIIlIIlIll", UserId = 9323915854},
        {Name = "IlIIIlIlIlIlIlIIllIl", UserId = 5729711908},
    }
}

local FARM_GROUP = {
    Leader = {Name = "lIIllIlIIllIlllIllIl", UserId = 5729713788},
    Members = {
        {Name = "BangBangYT4", UserId = 2011296277},
        {Name = "pablolookslikecheese", UserId = 3260873018},
        {Name = "sqpva", UserId = 3606502638},
    }
}

local ALL_ACCOUNTS = {
    5729726646, 5729724431, 9323915854, 5729711908, 5729713788, 2011296277, 3260873018, 3606502638
}

local PLACE_MAIN = 14067600077
local PLACE_MATCH = 18637069183
local PLACE_CASCADE = 138059541435332

local localPlayer = Players.LocalPlayer

-- DEBUG HELPER
local function debugPrint(message)
    print("[PARTY MANAGER DEBUG] " .. tostring(message))
end

-- PARTY CHECKER FUNCTIONS
local function getMembersFrame()
    local playerGui = localPlayer:FindFirstChild("PlayerGui")
    if not playerGui then 
        debugPrint("PlayerGui not found")
        return nil 
    end
    
    local menu = playerGui:FindFirstChild("Menu")
    if not menu or menu.ClassName ~= "ScreenGui" then 
        debugPrint("Menu ScreenGui not found")
        return nil 
    end
    
    local main = menu:FindFirstChild("Main")
    if not main or main.ClassName ~= "CanvasGroup" then 
        debugPrint("Main CanvasGroup not found")
        return nil 
    end
    
    local sidebar = main:FindFirstChild("Sidebar")
    if not sidebar or sidebar.ClassName ~= "Frame" then 
        debugPrint("Sidebar Frame not found")
        return nil 
    end
    
    local party = sidebar:FindFirstChild("Party")
    if not party or party.ClassName ~= "Frame" then 
        debugPrint("Party Frame not found")
        return nil 
    end
    
    local members = party:FindFirstChild("Members")
    if not members or members.ClassName ~= "Frame" then 
        debugPrint("Members Frame not found")
        return nil 
    end
    
    debugPrint("Successfully found Members frame")
    return members
end

local function getPartyMemberIds()
    local membersFrame = getMembersFrame()
    if not membersFrame then 
        debugPrint("Could not get members frame for party check")
        return {} 
    end
    
    local memberIds = {}
    for _, child in pairs(membersFrame:GetChildren()) do
        if child.ClassName == "Frame" then
            local userId = tonumber(child.Name)
            if userId then
                table.insert(memberIds, userId)
                debugPrint("Found party member: " .. tostring(userId))
            end
        end
    end
    
    debugPrint("Total party members found: " .. #memberIds)
    return memberIds
end

local function checkGroupMembersInParty(groupMembers)
    debugPrint("Checking if group members are in party...")
    local partyMemberIds = getPartyMemberIds()
    local partyMemberSet = {}
    
    -- Convert party member IDs to set for faster lookup
    for _, id in pairs(partyMemberIds) do
        partyMemberSet[id] = true
    end
    
    -- Check if all group members are in party
    for _, member in pairs(groupMembers) do
        if not partyMemberSet[member.UserId] then
            debugPrint("Group member " .. member.Name .. " (" .. member.UserId .. ") not in party")
            return false
        else
            debugPrint("Group member " .. member.Name .. " (" .. member.UserId .. ") is in party")
        end
    end
    
    debugPrint("All group members are in party!")
    return true
end

local function isPlayerInParty()
    local membersFrame = getMembersFrame()
    if not membersFrame then 
        return false 
    end
    
    -- If there are any members shown, we're likely in a party
    for _, child in pairs(membersFrame:GetChildren()) do
        if child.ClassName == "Frame" then
            return true
        end
    end
    
    return false
end

-- UTILITY FUNCTIONS
local function SendChatMessage(message)
    debugPrint("Sending chat message: " .. message)
    -- Check if the new TextChatService is being used
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        -- Send message using the new TextChatService
        local textChannel = TextChatService.TextChannels.RBXGeneral
        textChannel:SendAsync(message)
    else
        -- Send message using the default chat system
        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
    end
end

local function waitForGameLoaded()
    debugPrint("Waiting for game to load...")
    if not game:IsLoaded() then
        game.Loaded:Wait()
    end
    debugPrint("Game loaded successfully")
end

local function safeTeleport(placeId)
    debugPrint("Attempting to teleport to place: " .. tostring(placeId))
    local attempts = 0
    while true do
        attempts = attempts + 1
        debugPrint("Teleport attempt #" .. attempts)
        
        local success = pcall(function()
            TeleportService:Teleport(placeId, localPlayer)
        end)
        
        if success then 
            debugPrint("Teleport successful!")
            break 
        else
            debugPrint("Teleport failed, retrying in 5 seconds...")
        end
        task.wait(5)
    end
end

local function allAccountsInServer()
    local count = 0
    local accountsFound = {}
    
    for _, player in pairs(Players:GetPlayers()) do
        for _, accountId in pairs(ALL_ACCOUNTS) do
            if player.UserId == accountId then
                count = count + 1
                table.insert(accountsFound, player.Name .. " (" .. player.UserId .. ")")
                break
            end
        end
    end
    
    debugPrint("Accounts in server (" .. count .. "/" .. #ALL_ACCOUNTS .. "): " .. table.concat(accountsFound, ", "))
    return count == #ALL_ACCOUNTS
end

local function serverHasOnlySpecifiedAccounts()
    local specifiedAccountsInServer = {}
    local totalPlayersInServer = 0
    local allPlayersInServer = {}
    
    -- Count all players and track specified accounts
    for _, player in pairs(Players:GetPlayers()) do
        totalPlayersInServer = totalPlayersInServer + 1
        table.insert(allPlayersInServer, player.Name .. " (" .. player.UserId .. ")")
        
        for _, accountId in pairs(ALL_ACCOUNTS) do
            if player.UserId == accountId then
                specifiedAccountsInServer[accountId] = true
                break
            end
        end
    end
    
    -- Count how many specified accounts are present
    local specifiedCount = 0
    for _ in pairs(specifiedAccountsInServer) do
        specifiedCount = specifiedCount + 1
    end
    
    debugPrint("All players in server: " .. table.concat(allPlayersInServer, ", "))
    debugPrint("Specified accounts in server: " .. specifiedCount .. "/" .. totalPlayersInServer)
    
    local result = specifiedCount == totalPlayersInServer and specifiedCount > 0
    debugPrint("Server has only specified accounts: " .. tostring(result))
    return result
end

local function isLeaderInServer()
    for _, player in pairs(Players:GetPlayers()) do
        if player.UserId == MAIN_GROUP.Leader.UserId then
            debugPrint("Main group leader found in server: " .. player.Name)
            return true
        elseif player.UserId == FARM_GROUP.Leader.UserId then
            debugPrint("Farm group leader found in server: " .. player.Name)
            return true
        end
    end
    debugPrint("No leaders found in server")
    return false
end

local function tryJoinLeaderServer()
    debugPrint("Attempting to join leader server...")
    
    -- Only attempt if current player is a member (not a leader)
    if localPlayer.UserId == MAIN_GROUP.Leader.UserId or localPlayer.UserId == FARM_GROUP.Leader.UserId then
        debugPrint("Current player is a leader, no need to join")
        return -- Leaders don't need to join themselves
    end
    
    -- Check if this player belongs to any group
    local belongsToGroup = false
    for _, member in pairs(MAIN_GROUP.Members) do
        if localPlayer.UserId == member.UserId then
            belongsToGroup = true
            debugPrint("Player belongs to main group")
            break
        end
    end
    if not belongsToGroup then
        for _, member in pairs(FARM_GROUP.Members) do
            if localPlayer.UserId == member.UserId then
                belongsToGroup = true
                debugPrint("Player belongs to farm group")
                break
            end
        end
    end
    
    if not belongsToGroup then
        debugPrint("Player does not belong to any group, skipping join attempt")
        return -- Only group members should try to join leaders
    end
    
    -- Wait and check for leader before attempting joinserver
    for attempt = 1, 2 do
        debugPrint("Join leader attempt " .. attempt .. "/2")
        
        debugPrint("Waiting 20 seconds before checking for leader...")
        task.wait(20)
        
        -- Check if leader is now in server
        if isLeaderInServer() then
            debugPrint("Leader found in server after waiting, no need to join")
            return
        end
        
        debugPrint("Leader still not in server, sending joinserver command...")
        pcall(function()
            SendChatMessage("!joinserver " .. MAIN_GROUP.Leader.Name)
        end)
    end
end

local function waitForRemotesReady()
    debugPrint("Waiting for remotes to be ready...")
    local ready = false
    local attempts = 0
    while not ready and attempts < 60 do
        attempts = attempts + 1
        debugPrint("Remote check attempt " .. attempts .. "/60")
        
        ready = pcall(function()
            ReplicatedStorage:WaitForChild("Remotes", 1)
            ReplicatedStorage.Remotes:WaitForChild("Team", 1)
            return true
        end)
        
        if not ready then 
            task.wait(1) 
        end
    end
    
    if ready then
        debugPrint("Remotes are ready!")
    else
        debugPrint("Remotes failed to load after 60 attempts")
    end
    
    return ready
end

-- IMPROVED PARTY MANAGEMENT FUNCTIONS
local function inviteAndWaitForMembers()
    if localPlayer.Name == MAIN_GROUP.Leader.Name then
        debugPrint("Main group leader inviting members...")
        
        -- Check if party is already complete
        if checkGroupMembersInParty(MAIN_GROUP.Members) then
            debugPrint("Party already complete for main group")
            task.wait(2)
            return true
        end
        
        local startTime = tick()
        local timeout = 60 -- 60 seconds timeout
        local inviteInterval = 2 -- Send invites every 2 seconds
        local lastInviteTime = 0
        
        debugPrint("Starting continuous invite loop with " .. timeout .. "s timeout")
        
        while (tick() - startTime) < timeout do
            local currentTime = tick()
            
            -- Send invites every 2 seconds
            if (currentTime - lastInviteTime) >= inviteInterval then
                debugPrint("Sending invites to main group members... (elapsed: " .. math.floor(currentTime - startTime) .. "s)")
                
                for _, member in pairs(MAIN_GROUP.Members) do
                    pcall(function()
                        local targetPlayer = Players:FindFirstChild(member.Name)
                        if targetPlayer then
                            local args = {"Invite", targetPlayer}
                            ReplicatedStorage.Remotes.Team:FireServer(unpack(args))
                        else
                            debugPrint("Could not find " .. member.Name .. " in server")
                        end
                    end)
                end
                
                lastInviteTime = currentTime
            end
            
            -- Check if all members joined every second
            if checkGroupMembersInParty(MAIN_GROUP.Members) then
                debugPrint("All main group members joined party successfully! (took " .. math.floor(currentTime - startTime) .. "s)")
                task.wait(1)
                return true
            end
            
            task.wait(1) -- Check every second
        end
        
        debugPrint("Invite timeout reached for main group (" .. timeout .. "s)")
        return false
        
    elseif localPlayer.Name == FARM_GROUP.Leader.Name then
        debugPrint("Farm group leader inviting members...")
        
        -- Check if party is already complete
        if checkGroupMembersInParty(FARM_GROUP.Members) then
            debugPrint("Party already complete for farm group")
            task.wait(2)
            return true
        end
        
        local startTime = tick()
        local timeout = 60 -- 60 seconds timeout
        local inviteInterval = 2 -- Send invites every 2 seconds
        local lastInviteTime = 0
        
        debugPrint("Starting continuous invite loop with " .. timeout .. "s timeout")
        
        while (tick() - startTime) < timeout do
            local currentTime = tick()
            
            -- Send invites every 2 seconds
            if (currentTime - lastInviteTime) >= inviteInterval then
                debugPrint("Sending invites to farm group members... (elapsed: " .. math.floor(currentTime - startTime) .. "s)")
                
                for _, member in pairs(FARM_GROUP.Members) do
                    pcall(function()
                        local targetPlayer = Players:FindFirstChild(member.Name)
                        if targetPlayer then
                            local args = {"Invite", targetPlayer}
                            ReplicatedStorage.Remotes.Team:FireServer(unpack(args))
                        else
                            debugPrint("Could not find " .. member.Name .. " in server")
                        end
                    end)
                end
                
                lastInviteTime = currentTime
            end
            
            -- Check if all members joined every second
            if checkGroupMembersInParty(FARM_GROUP.Members) then
                debugPrint("All farm group members joined party successfully! (took " .. math.floor(currentTime - startTime) .. "s)")
                task.wait(1)
                return true
            end
            
            task.wait(1) -- Check every second
        end
        
        debugPrint("Invite timeout reached for farm group (" .. timeout .. "s)")
        return false
    end
    
    debugPrint("Player is not a leader, cannot invite members")
    return false
end

local function acceptInvites()
    debugPrint("Attempting to accept invites...")
    local leaderName = nil
    
    -- Determine which leader to accept invites from
    for _, member in pairs(MAIN_GROUP.Members) do
        if localPlayer.Name == member.Name then
            leaderName = MAIN_GROUP.Leader.Name
            debugPrint("Player is main group member, will accept invites from " .. leaderName)
            break
        end
    end
    
    if not leaderName then
        for _, member in pairs(FARM_GROUP.Members) do
            if localPlayer.Name == member.Name then
                leaderName = FARM_GROUP.Leader.Name
                debugPrint("Player is farm group member, will accept invites from " .. leaderName)
                break
            end
        end
    end
    
    if leaderName then
        local startTime = tick()
        local timeout = 60 -- 60 seconds timeout (same as invite timeout)
        local acceptInterval = 2 -- Try to accept every 2 seconds
        local lastAcceptTime = 0
        
        debugPrint("Starting continuous accept loop with " .. timeout .. "s timeout")
        
        while (tick() - startTime) < timeout do
            local currentTime = tick()
            
            -- Check if we're already in a party
            if isPlayerInParty() then
                debugPrint("Player is now in a party! (took " .. math.floor(currentTime - startTime) .. "s)")
                return true
            end
            
            -- Try to accept invites every 2 seconds
            if (currentTime - lastAcceptTime) >= acceptInterval then
                debugPrint("Attempting to accept invite from " .. leaderName .. "... (elapsed: " .. math.floor(currentTime - startTime) .. "s)")
                
                pcall(function()
                    local leaderPlayer = Players:FindFirstChild(leaderName)
                    if leaderPlayer then
                        local args = {"AcceptInvite", leaderPlayer}
                        ReplicatedStorage.Remotes.Team:FireServer(unpack(args))
                    else
                        debugPrint("Could not find leader " .. leaderName .. " in server")
                    end
                end)
                
                lastAcceptTime = currentTime
            end
            
            task.wait(1) -- Check every second
        end
        
        debugPrint("Accept timeout reached (" .. timeout .. "s)")
        return false
    else
        debugPrint("Player is not a group member, no invites to accept")
        return false
    end
end

local function startQueue()
    debugPrint("Starting queue process...")
    
    if localPlayer.UserId == MAIN_GROUP.Leader.UserId or localPlayer.UserId == FARM_GROUP.Leader.UserId then
        debugPrint("Player is a leader, starting queue...")
        for attempt = 1, 8 do
            debugPrint("Queue attempt " .. attempt .. "/8")
            pcall(function()
                local args = {"JoinQueue", "CASCADE"}
                ReplicatedStorage.Remotes.Team:FireServer(unpack(args))
            end)
            
            if attempt < 8 then
                task.wait(2)
            end
        end
        
        debugPrint("Waiting 5 seconds after initial queue attempts...")
        task.wait(5)
        
        if game.PlaceId == PLACE_MATCH then
            debugPrint("Still in match place, sending additional queue requests...")
            for attempt = 1, 4 do
                debugPrint("Additional queue attempt " .. attempt .. "/4")
                pcall(function()
                    local args = {"JoinQueue", "CASCADE"}
                    ReplicatedStorage.Remotes.Team:FireServer(unpack(args))
                end)
                task.wait(3)
            end
        end
        
    elseif isMainGroupMember() or isFarmGroupMember() then
        debugPrint("Player is a group member, joining queue...")
        task.wait(2)
        for attempt = 1, 8 do
            debugPrint("Member queue attempt " .. attempt .. "/8")
            pcall(function()
                local args = {"JoinQueue", "CASCADE"}
                ReplicatedStorage.Remotes.Team:FireServer(unpack(args))
            end)
            if attempt < 8 then
                task.wait(2)
            end
        end
    else
        debugPrint("Player is not in any group, not joining queue")
    end
end

local function isMainGroupMember()
    if localPlayer.UserId == MAIN_GROUP.Leader.UserId then return true end
    for _, member in pairs(MAIN_GROUP.Members) do
        if localPlayer.UserId == member.UserId then return true end
    end
    return false
end

local function isFarmGroupMember()
    if localPlayer.UserId == FARM_GROUP.Leader.UserId then return true end
    for _, member in pairs(FARM_GROUP.Members) do
        if localPlayer.UserId == member.UserId then return true end
    end
    return false
end

-- MAIN EXECUTION
local function runPartyManager()
    debugPrint("=== PARTY MANAGER STARTED ===")
    debugPrint("Player: " .. localPlayer.Name .. " (ID: " .. localPlayer.UserId .. ")")
    debugPrint("Current Place ID: " .. game.PlaceId)
    
    waitForGameLoaded()
    
    local matchStartTime = tick()
    debugPrint("Match start time initialized: " .. matchStartTime)
    
    while true do
        if game.PlaceId == PLACE_MAIN then
            debugPrint("Currently in MAIN place, teleporting to MATCH...")
            safeTeleport(PLACE_MATCH)
            matchStartTime = tick() -- Reset timer on place change
            debugPrint("Reset match start time: " .. matchStartTime)
            
        elseif game.PlaceId == PLACE_MATCH then
            debugPrint("Currently in MATCH place")
            
            -- Check if no leader is in server and try to join one
            if not isLeaderInServer() then
                debugPrint("No leader in server, attempting to join leader...")
                tryJoinLeaderServer()
            end
            
            -- Wait for all accounts to be in server
            debugPrint("Waiting for all accounts to be in server...")
            local waitingForAccounts = true
            while waitingForAccounts do
                debugPrint("Checking for all accounts in server...")
                
                if allAccountsInServer() then
                    debugPrint("All accounts are in server! Proceeding...")
                    waitingForAccounts = false
                    local remotesReady = waitForRemotesReady()
                    
                    if remotesReady then
                        debugPrint("Waiting 3 seconds before party operations...")
                        task.wait(3)
                        
                        -- For leaders: invite and wait for members to join party
                        if localPlayer.UserId == MAIN_GROUP.Leader.UserId or localPlayer.UserId == FARM_GROUP.Leader.UserId then
                            debugPrint("Player is a leader, managing party...")
                            local partyReady = inviteAndWaitForMembers()
                            if partyReady then
                                debugPrint("Party is ready, starting queue...")
                                startQueue()
                                debugPrint("Waiting 10 seconds after queue start...")
                                task.wait(10)
                            else
                                debugPrint("Party setup failed")
                            end
                        else
                            -- For members: accept invites
                            debugPrint("Player is a member, accepting invites and joining queue...")
                            acceptInvites()
                            startQueue()
                            debugPrint("Waiting 10 seconds after queue join...")
                            task.wait(10)
                        end
                    else
                        debugPrint("Remotes not ready, skipping party operations")
                    end
                else
                    debugPrint("Not all accounts in server yet, waiting 15 seconds...")
                    task.wait(15)
                end
            end
            
        elseif game.PlaceId == PLACE_CASCADE then
            debugPrint("Currently in CASCADE place")
            
            -- Check if server contains only specified accounts
            if not serverHasOnlySpecifiedAccounts() then
                -- If server has players that aren't in our account list, teleport immediately
                debugPrint("Server has non-specified accounts, teleporting to MATCH immediately")
                safeTeleport(PLACE_MATCH)
                matchStartTime = tick()
            else
                -- Original logic if server only has specified accounts
                debugPrint("Server has only specified accounts, proceeding with normal logic")
                debugPrint("Waiting 5 seconds...")
                task.wait(5)
                
                if isFarmGroupMember() then
                    debugPrint("Player is farm group member, teleporting to MATCH")
                    safeTeleport(PLACE_MATCH)
                    matchStartTime = tick()
                end
                
                debugPrint("Waiting 10 seconds...")
                task.wait(10)
                
                if isMainGroupMember() then
                    debugPrint("Player is main group member, teleporting to MATCH")
                    safeTeleport(PLACE_MATCH)
                    matchStartTime = tick()
                end
            end
        else
            debugPrint("Unknown place ID: " .. game.PlaceId .. ", waiting...")
        end
        
        task.wait(1)
    end
end

-- START SCRIPT
debugPrint("Spawning party manager...")
spawn(runPartyManager)
